#! /usr/bin/perl -w

$seed = 17;
srand($seed);
$pi = 4*atan2(1.0, 1.0);
$per = 25;
$incr = (2*$pi)/$per;
@dq = ();
$vector_count = 0;

print <<PREAMBLE;
    (load \"deque.scm\")  ; EDIT HERE the implementation under test and see prerequisite
    ; PREREQUISITE: modify the implementation under test so that delete from an empty deque is a NOP
    ; This test bench was generated by the script '$0'
    (define q1 (make-deque))
PREAMBLE

sub status {
    my ($cardinal, $expected_left, $expected_right) = @_;

    ++$vector_count;
    print "; the dq is @dq\n";
    if (0 == $cardinal) {
        print "(if (empty-deque? q1) 'ok (error \"Error: Mismatch empty check $vector_count\"))\n";
    }
    else {
        print <<EOF;
    (if (= $expected_left (front-deque q1))
        'ok (error \"Error: Mismatch front check $vector_count\" $expected_left))
    (if (= $expected_right (rear-deque q1))
        'ok (error \"Error: Mismatch rear check $vector_count\" $expected_right))
EOF
    }
}

for ($idx = 0; $idx < 1000; ++$idx) {
    my $x = $idx * $incr;
    my $p = 0.40 + sin($x)/2.0;
    #printf ("sin %2.2f %2.4f\n", $x, $p);

    ($r1, $r2, $r3) = (rand, rand, rand);

    if ( $r1 < $p ) {
	my $v = ($r2 * 1000) % 1000;

        if ($r2 < 0.5) { print "  (front-insert-deque! q1 $v)\n";  unshift @dq, $v; }
	else           { print "  (rear-insert-deque! q1 $v)\n";   push @dq, $v; }
    }
    else {
        if ($r2 < 0.5) { print "  (front-delete-deque! q1)\n";  shift @dq; }
	else           { print "  (rear-delete-deque!  q1)\n";  pop @dq; }
    }

    if ($r3 < 0.20) {
        status(scalar(@dq), $dq[0], $dq[$#dq]);
    }
}
